// ======================================================================
// \title  StateToJunctionStateMachineAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for StateToJunction state machine
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "state/StateToJunctionStateMachineAc.hpp"

namespace FppTest {

  namespace SmState {

    // ----------------------------------------------------------------------
    // Constructors and Destructors
    // ----------------------------------------------------------------------

    StateToJunctionStateMachineBase ::
      StateToJunctionStateMachineBase()
    {

    }

    StateToJunctionStateMachineBase ::
      ~StateToJunctionStateMachineBase()
    {

    }

    // ----------------------------------------------------------------------
    // Initialization
    // ----------------------------------------------------------------------

    void StateToJunctionStateMachineBase ::
      initBase(const FwEnumStoreType id)
    {
      this->m_id = id;
      this->enter_S1(Signal::__FPRIME_AC_INITIAL_TRANSITION);
    }

    // ----------------------------------------------------------------------
    // Getter functions
    // ----------------------------------------------------------------------

    StateToJunctionStateMachineBase::State StateToJunctionStateMachineBase ::
      getState() const
    {
      return this->m_state;
    }

    // ----------------------------------------------------------------------
    // Send signal functions
    // ----------------------------------------------------------------------

    void StateToJunctionStateMachineBase ::
      sendSignal_S1_to_S4()
    {
      switch (this->m_state) {
        case State::S1_S2:
          this->action_exitS2(Signal::S1_to_S4);
          this->action_exitS1(Signal::S1_to_S4);
          this->action_a(Signal::S1_to_S4);
          this->enter_S4(Signal::S1_to_S4);
          break;
        case State::S1_S3:
          this->action_exitS3(Signal::S1_to_S4);
          this->action_exitS1(Signal::S1_to_S4);
          this->action_a(Signal::S1_to_S4);
          this->enter_S4(Signal::S1_to_S4);
          break;
        case State::S4_S5:
          break;
        case State::S4_S6:
          break;
        default:
          FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
          break;
      }
    }

    void StateToJunctionStateMachineBase ::
      sendSignal_S1_to_J()
    {
      switch (this->m_state) {
        case State::S1_S2:
          this->action_exitS2(Signal::S1_to_J);
          this->action_exitS1(Signal::S1_to_J);
          this->action_a(Signal::S1_to_J);
          this->action_enterS4(Signal::S1_to_J);
          this->enter_S4_J(Signal::S1_to_J);
          break;
        case State::S1_S3:
          this->action_exitS3(Signal::S1_to_J);
          this->action_exitS1(Signal::S1_to_J);
          this->action_a(Signal::S1_to_J);
          this->action_enterS4(Signal::S1_to_J);
          this->enter_S4_J(Signal::S1_to_J);
          break;
        case State::S4_S5:
          break;
        case State::S4_S6:
          break;
        default:
          FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
          break;
      }
    }

    void StateToJunctionStateMachineBase ::
      sendSignal_S2_to_S3()
    {
      switch (this->m_state) {
        case State::S1_S2:
          this->action_exitS2(Signal::S2_to_S3);
          this->enter_S1_S3(Signal::S2_to_S3);
          break;
        case State::S1_S3:
          break;
        case State::S4_S5:
          break;
        case State::S4_S6:
          break;
        default:
          FW_ASSERT(0, static_cast<FwAssertArgType>(this->m_state));
          break;
      }
    }

    // ----------------------------------------------------------------------
    // State and junction entry
    // ----------------------------------------------------------------------

    void StateToJunctionStateMachineBase ::
      enter_S4(Signal signal)
    {
      this->action_enterS4(signal);
      this->enter_S4_J(signal);
    }

    void StateToJunctionStateMachineBase ::
      enter_S4_J(Signal signal)
    {
      if (this->guard_g(signal)) {
        this->enter_S4_S5(signal);
      }
      else {
        this->enter_S4_S6(signal);
      }
    }

    void StateToJunctionStateMachineBase ::
      enter_S4_S5(Signal signal)
    {
      this->m_state = State::S4_S5;
    }

    void StateToJunctionStateMachineBase ::
      enter_S4_S6(Signal signal)
    {
      this->m_state = State::S4_S6;
    }

    void StateToJunctionStateMachineBase ::
      enter_S1(Signal signal)
    {
      this->action_enterS1(signal);
      this->enter_S1_S2(signal);
    }

    void StateToJunctionStateMachineBase ::
      enter_S1_S2(Signal signal)
    {
      this->action_enterS2(signal);
      this->m_state = State::S1_S2;
    }

    void StateToJunctionStateMachineBase ::
      enter_S1_S3(Signal signal)
    {
      this->action_enterS3(signal);
      this->m_state = State::S1_S3;
    }

  }

}
