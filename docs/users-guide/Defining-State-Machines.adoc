== Defining State Machines

A *hierarchical state machine* (state machine for short)
is a software subsystem that specifies the following:

* A set of *states* that the system can be in.
The states can be arranged in a hierarchy (i.e.,
states may have substates).

* A set of *transitions* from one state to another that
occur under specified conditions.

State machines are important in embedded programming.
For example, F Prime components often have a concept of state
that changes as the system runs, and it is useful to model
these state changes as a state machine.

In FPP there are two ways to define a state machine:

. An *external* state machine definition is like
an <<Defining-Types_Abstract-Type-Definitions,abstract type definition>>:
it tells the analyzer that a state machine exists with a specified
name, but it says nothing about the state machine behavior.
An external tool must provide the state machine implementation.

. An *internal* state machine definition is like an
<<Defining-Types_Array-Type-Definitions,array type definition>>
or
<<Defining-Types_Struct-Type-Definitions,struct type definition>>:
it provides a complete specification in FPP of the state machine behavior.
The FPP back end uses this specification to generate code;
no external tool is required.

The following subsections describe both kinds of state machine
definitions.

State machine definitions may appear at the top level or inside a
<<Defining-Modules,module definition>>.
A state machine definition is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>.
Once you define a state machine, you can
<<Defining-Components_State-Machine-Instances,
instantiate it as part of a component>>.
The component can then send the signals that cause the state
transitions.

=== External State Machines

To define an external state machine, you write the keywords
`state` `machine` followed by an identifier, which is the
name of the state machine:

[source,fpp]
----
state machine M
----

This code defines an external state machine with name `M`.

When you define an external state machine `M`, you must provide
an implementation for `M`, as discussed in the section
on <<Writing-C-Plus-Plus-Implementations_Implementing-External-State-Machines,
implementing external state machines>>.
The external implementation must have a header file `M.hpp`
located in the same directory as the FPP file where
the state machine `M` is defined.

=== Internal State Machines

In the remainder of this section, we explain how to define internal
state machines in FPP.
The behavior of these state machines closely follows the behavior
described for 
https://www.omg.org/spec/UML/2.5.1/PDF[state machines in the
Universal Modeling Language (UML)]. 
UML is a graphical language and FPP is a textual language,
but each of the concepts in the FPP language is motivated
by a corresponding UML concept.
Note that FPP does not represent every aspect of UML state machines:
because our goal is to support embedded and flight software,
we focus on a subset of UML state machine behavior that is
(1) simple and unambiguous and (2) sufficient for embedded
applications that use F Prime.

=== States, Transitions, and Signals

The simplest state machine _M_ that has any useful
behavior consists of the following:

* Several *state definitions*.
These define the states of _M_.

* An *initial transition specifier*.
This specifies the state that an instance of _M_ is in when it starts up.

* One or more *signal definitions*.
The external environment (typically an F Prime component)
sends signals to instances of _M_.

* One or more *state transition specifiers*.
These tell each instance of _M_ what to do when it receives a signal.

Here is an example:

[source,fpp]
----
@ A state machine representing a device with on-off behavior
state machine Device {

  @ A signal for turning the device on
  signal cmdOn

  @ A signal for turning the device off
  signal cmdOff

  @ The initial state is OFF
  initial enter OFF

  @ The ON state
  state ON {

    @ In the ON state, a cmdOff signal causes a transition to the OFF state
    on cmdOff enter OFF

  }

  @ The OFF state
  state OFF {

    @ In the OFF state, a cmdOff signal causes a transition to the ON state
    on cmdOn enter ON

  }

}
----

This example defines a state machine `Device` that represents
a device with on-off behavior.
There are two states, `ON` and `OFF`.
The initial transition specifier `initial enter OFF`
says that the state machine is in state `OFF` when it starts up.
There are two signals: `cmdOn` for turning the device
on and `cmdOff` for turning the device off.
There are two state transition specifiers:

* A specifier that says to enter state `OFF` 
on receiving the `cmdOff` signal in state `ON`.

* A specifier that says to enter state `ON`
on receiving the `cmdOn` signal in state `OFF`.

In general, a state transition specifier causes a transition
from the state _S_ in which it appears to the state _T_ that
appears after the keyword `enter`.
We say that _S_ is the *source* of the transition,
and _T_ is the *target* of the transition.

If a state machine instance receives a signal _s_, and it is
in a state _S_ that specifies no behavior for signal _s_
(i.e., there is no transition with source _S_ and signal _s_),
then nothing happens.
In the example above, if the state machine receives signal
`cmdOn` in state `ON`
or signal `cmdOff` in state `OFF`, then it takes no action.

*Rules for writing state machine definitions:*
State machine definitions must conform to the following rules:

. A state machine definition and each of its members is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>.
For example, you can annotate the `Device` state machine as shown above.
The members of a state machine definition form an
<<Defining-Constants_Multiple-Definitions-and-Element-Sequences,
element sequence>> with a semicolon as the optional
terminating punctuation.
The same rules apply to the members of a state definition.

. Each state machine definition must have exactly one
initial transition specifier that names a state of
the state machine.
For example, if we deleted the initial transition specifier
from the example above and passed the result through
`fpp-check`, and error would occur.

. Every state definition must be reachable from the initial
transition specifier or from a state transition specifier.
For example, if we deleted the state transition specifier
in the state `ON` from the example above and passed
the result through `fpp-check`, an error would occur.
In this case, there would be no way to reach the `ON` state.

. Every state name must be unique, and every signal name
must be unique.

. Each state may have at most one state transition specifier
for each signal _s_.
For example, if we added another transition to state `ON`
on signal `cmdOff`, the FPP analyzer would report an error.

*Simple state definitions:*
If a state definition has no transitions, then you can omit
the braces.
For example, here is a revised version of the `Device` state
machine that has an off-on transition but no on-off transition:

[source,fpp]
----
@ A state machine representing a device with on-only behavior
state machine Device {

  @ A signal for turning the device on
  signal cmdOn

  @ The initial state is OFF
  initial enter OFF

  @ The ON state
  state ON

  @ The OFF state
  state OFF {

    @ In the OFF state, a cmdOff signal causes a transition to the ON state
    on cmdOn enter ON

  }

}
----

Notice that state `ON` has a simple definition with no curly braces.

=== Actions

An *action* is a function that a state machine calls at a
specified point in its behavior.
In the FPP model, actions are abstract;
in the {cpp} back end they become pure virtual functions that
you implement.
Running the function for an action _A_ is called 
*doing* _A_.

To define an action, you write the keyword `action` followed
by the name of the action.
As with <<Defining-State-Machines_States-Transitions-and-Signals,signals>>,
every action name must be unique.
To do an action, you write the keyword `do`
followed by a list of action names enclosed in curly braces.
You can do this in an initial transition specifier or in a
state transition specifier.

As an example, here is the `Device` state machine from the
previous section, with actions added:

[source,fpp]
----
@ A state machine representing a device with on-off behavior,
@ with actions on transitions
state machine Device {

  @ Initial action 1
  action initialAction1

  @ Initial action 2
  action initialAction2

  @ An action on the transition from OFF to ON
  action offOnAction

  @ An action on the transition from ON to OFF
  action onOffAction

  @ A signal for turning the device on
  signal cmdOn

  @ A signal for turning the device off
  signal cmdOff

  @ The initial state is OFF
  @ Before entering the initial state, do initialAction1 and then initialAction2
  initial do { initialAction1, initialAction2 } enter OFF

  @ The ON state
  state ON {

    @ In the ON state, a cmdOff signal causes a transition to the OFF state
    @ Before entering the OFF state, do onOffAction
    on cmdOff do { onOffAction } enter OFF

  }

  @ The OFF state
  state OFF {

    @ In the OFF state, a cmdOff signal causes a transition to the ON state
    @ Before entering the ON state, do offOnAction
    on cmdOn do { offOnAction } enter ON

  }

}
----

In this example there are four actions:
`initialAction1`, `initialAction2`, `offOnAction`, and `onOffAction`.
The behavior of each of these actions is specified in the {cpp}
implementation; for example, each could emit an 
<<Defining-Components_Events,F Prime event>>.
The state machine has the following behavior:

* On startup, do `initialAction1`, do `initialAction2`, and
enter the `OFF` state.

* In state `OFF`, on receiving the `cmdOn` signal, do
`offOnAction` and enter the `ON` state.

* In state `ON`, on receiving the `cmdOff` signal, do
`onOffAction` and enter the `OFF` state.

When multiple actions appear in an action list, as in the initial
transition specifier shown above, the actions occur in the order
listed.
Each action list is an
<<Defining-Constants_Multiple-Definitions-and-Element-Sequences,
element sequence>> with a comma as the optional
terminating punctuation.

=== State Entry and Exit Specifiers

In addition to doing actions on transitions, a state machine
can do actions on entry to or exit from a state.
To do actions like this, you write *state entry specifiers*
and *state exit specifiers*.
For example, here is the `Device` state machine from
the previous section, with state entry and exit specifiers
added to the `ON` and `OFF` states:

[source,fpp]
----
@ A state machine representing a device with on-off behavior,
@ with actions on transitions and on state entry and exit
state machine Device {

  @ Initial action 1
  action initialAction1

  @ Initial action 2
  action initialAction2

  @ An action on the transition from OFF to ON
  action offOnAction

  @ An action on the transition from ON to OFF
  action onOffAction

  @ An action on entering the ON state
  action enterOn

  @ An action on exiting the ON state
  action exitOn

  @ An action on entering the OFF state
  action enterOff

  @ An action on exiting the OFF state
  action exitOff

  @ A signal for turning the device on
  signal cmdOn

  @ A signal for turning the device off
  signal cmdOff

  @ The initial state is OFF
  @ Before entering the initial state, do initialAction1 and then initialAction2
  initial do { initialAction1, initialAction2 } enter OFF

  @ The ON state
  state ON {

    @ On entering the ON state, do enterOn
    entry do { enterOn }

    @ In the ON state, a cmdOff signal causes a transition to the OFF state
    @ Before entering the OFF state, do offAction
    on cmdOff do { onOffAction } enter OFF

    @ On exiting the ON state, do exitOn
    exit do { exitOn }

  }

  @ The OFF state
  state OFF {

    @ On entering the OFF state, do enterOff
    entry do { enterOff }

    @ In the OFF state, a cmdOff signal causes a transition to the ON state
    @ Before entering the ON state, do onAction
    on cmdOn do { offOnAction } enter ON

    @ On exiting the OFF state, do exitOff
    exit do { exitOff }

  }

}
----

As with actions on transitions, each entry or exit specifier names
a list of actions, and the actions are done in the order named.
The entry actions are done just before entering the state,
and the exit actions are done just before exiting the state.
For example, if the state machine is in state `OFF` and it
receives a `cmdOn` signal, then it runs the following behavior,
in the following order:

* Exit state `OFF`. On exit, do `exitOff`.

* Transition from `OFF` to `ON`. On the transition, do `offOnAction`.

* Enter state `ON`. On entry, do `enterOn`.

Each state may have at most one entry specifier and at most one
exit specifier.

=== Typed Signals and Actions

Optionally, signals and actions may carry data values.
To specify that a signal or action carries a data value,
you write a colon and a data type at the end of the
signal or action specifier.
For example, here is a `Device` state machine in which
the `cmdOn` signal and the `offOnAction` each carries
a `U32` counter value:

[source,fpp]
----
@ A state machine representing a device with on-off behavior,
@ with actions on transitions
state machine Device {

  @ An action on the transition from OFF to ON
  @ The value counts the number of times this action has occurred
  action offOnAction: U32

  @ A signal for turning the device on
  @ The value counts the number of times this signal has been received
  signal cmdOn: U32

  @ A signal for turning the device off
  signal cmdOff

  @ The initial state is OFF
  initial enter OFF

  @ The ON state
  state ON {

    @ In the ON state, a cmdOff signal causes a transition to the OFF state
    on cmdOff enter OFF

  }

  @ The OFF state
  state OFF {

    @ In the OFF state, a cmdOff signal causes a transition to the ON state
    @ Before entering the ON state, do offOnAction, passing the data from
    @ the signal into the action
    on cmdOn do { offOnAction } enter ON

  }

}
----

When you send the `cmdOn` signal to an instance of
this state machine, you must provide a `U32` value.
When the state machine is in the `OFF` state and it receives
this signal, it does action `offOnAction` as shown.
The function that defines the behavior of `offOnAction` has
a single argument of type `U32`.
The value provided when the signal is sent is passed as the
argument to this function.

Here are the rules for writing typed signals and actions:

* When you do an action that has a type, a value
compatible with that type must be available.
For example, we can't do the `offOnAction` in the `cmdOff` transition shown 
above, because no `U32`
value is available there.
Similarly, no action done in a
<<Defining-State-Machines_State-Entry-and-Exit-Specifiers,
state entry or exit specifier>> may carry a value,
because no values are available on entry to or exit
from a state.

* The type that appears in a signal or an action can
be any FPP type.
In the example above we used a simple `U32` type;
we could have used, for example, a struct or array type.
In particular, you can use a struct type to send several
data values, with each value represented as a member
of the struct.

* When doing an action with a value, you don't have to
make the types exactly match.
For example, you are permitted to pass a `U16` value
to an action that requires a `U32` value.
However, the type of the value must be convertible to the type
specified in the action.
The type conversion rules are spelled out in full in
_The FPP Language Specification_.
In general, the analyzer will allow a conversion if it
can be safely done for all values of the original type.

* If an action _A_ does not carry any value, then you
can do _A_ in any context, even if a value is available there.
For example, in the code shown above, the `cmdOn`
transition could do some other action that carries no value.
In this case the value is ignored when doing the action.

=== Guarded Transitions

Sometimes it is useful to specify that a transition should occur
only if a certain condition is true.
For example, you may want to turn on a device, but only if
it is safe to do so.
We call this kind of transition a *guarded transition*.
To specify this transition, you define a *guard*, which
is an abstract function that returns a Boolean value.
Then you use the guard in a transition.
Here is an example:

[source,fpp]
----
@ A device state machine with a guarded transition
state machine Device {

  @ A guard for checking whether the device is in a safe state for power-on
  guard powerOnIsSafe

  @ A signal for turning the device on
  signal cmdOn

  @ A signal for turning the device off
  signal cmdOff

  @ The initial state is OFF
  initial enter OFF

  @ The ON state
  state ON {

    @ In the ON state, a cmdOff signal causes a transition to the OFF state
    on cmdOff enter OFF

  }

  @ The OFF state
  state OFF {

    @ In the OFF state, a cmdOff signal causes a transition to the ON state
    @ if powerOnIsSafe evaluates to true. Otherwise no transition occurs.
    on cmdOn if powerOnIsSafe enter ON

  }

}
----

In this example, there is one guard, `powerOnIsSafe`.
The implementation of this function will return true
if it is safe to power on the device; otherwise it will
return false.
In state `OFF`, the transition on signal `cmdOn` is
now guarded: when the signal is received in this state,
the transition occurs if and only if `powerOnIsSafe`
evaluates to `true`.

As with actions, each guard must have a unique name.
Also as with actions, a guard can have a type; if it does,
the type must match the type of the signal at the point
where the guard is evaluated.
For example, here is a revised version of the previous
state machine that adds a value of type `DeviceStatus`
to the guard `powerOnIsSafe`:

[source,fpp]
----
@ A type representing the status of a device
type DeviceStatus

@ A device state machine with a guarded transition
state machine Device {

  @ A guard for checking whether the device is in a safe state for power-on
  @ The DeviceStatus value provides the current device status
  guard powerOnIsSafe: DeviceStatus

  @ A signal for turning the device on
  @ The DeviceStatus value provides the current device status
  signal cmdOn: DeviceStatus

  @ A signal for turning the device off
  signal cmdOff

  @ The initial state is OFF
  initial enter OFF

  @ The ON state
  state ON {

    @ In the ON state, a cmdOff signal causes a transition to the OFF state
    on cmdOff enter OFF

  }

  @ The OFF state
  state OFF {

    @ In the OFF state, a cmdOff signal causes a transition to the ON state
    @ if powerOnIsSafe evaluates to true. Otherwise no transition occurs.
    on cmdOn if powerOnIsSafe enter ON

  }

}
----

When you send the signal `cmdOn` to an instance of this state
machine, you must provide a value of type `DeviceStatus`.
When the state machine instance evaluates the guard `powerOnIsSafe`,
it passes in the value as an argument to the function.

=== Self Transitions

When a state transition has the same state _S_ as its source
and its target, we call the transition a *self transition*.
In this case the following behavior occurs:

* The state machine does the exit actions for _S_, if any.

* The state machine does the actions specified in the transition, if any.

* The state machine does the entry actions for _S_ if any.

Note that on a self transition, the state machine exits and
reenters _S_.
This behavior is a special case of a more general behavior that we will
discuss below in connection with state hierarchy.

As an example, consider the following state machine:

[source,fpp]
----
@ A state machine representing a device with on-off behavior,
@ with a self transition
state machine Device {

  @ An action on entering the ON state
  action enterOn

  @ An action to perform on reset
  action reset

  @ An action on exiting the ON state
  action exitOn

  @ A signal for turning the device on
  signal cmdOn

  @ A signal for turning the device off
  signal cmdOff

  @ A signal for resetting the device
  signal cmdReset

  @ The initial state is OFF
  @ Before entering the initial state, do initialAction1 and then initialAction2
  initial enter OFF

  @ The ON state
  state ON {

    @ On entering the ON state, do enterOn
    entry do { enterOn }

    @ In the ON state, a cmdOff signal causes a transition to the OFF state
    on cmdOff enter OFF

    @ In the ON state, a cmdReset signal causes a self transition
    on cmdReset do { reset } enter ON

    @ On exiting the ON state, do exitOn
    exit do { exitOn }

  }

  @ The OFF state
  state OFF {

    @ In the OFF state, a cmdOff signal causes a transition to the ON state
    on cmdOn enter ON

  }

}
----

In this example, when the state machine is in the `ON` state and
it receives a `cmdReset` signal, the following behavior occurs:

* Do action `exitOn`.

* Do action `reset`.

* Do action `enterOn`.

=== Internal Transitions

TODO

=== Choices

TODO

* Basic
* With actions

* Rules
** Reachability
** No choice cycles
** Types must work out at choices

=== State Hierarchy

TODO

==== States within States

TODO

* Rules
** Exactly one initial transition specifier
** Initial transition specifier must lead to a peer state

==== Inherited Transitions

TODO

==== Transitions to Parent States

TODO

==== Choices within States

TODO

* Rules
** Initial transition specifier must lead to a peer state or choice
