== Defining State Machines

A *hierarchical state machine* (state machine for short)
specifies the following:

* A set of *states* that a system can be in.
The states can be arranged in a hierarchy (i.e.,
states may have substates).

* A set of *transitions* from one state to another that
occur under specified conditions.

State machines are important in embedded programming.
For example, F Prime components often have a concept of state
that changes as the system runs, and it is useful to model
these state changes as a state machine.

In FPP there are two ways to define a state machine:

. An *external* state machine definition is similar to
an <<Defining-Types_Abstract-Type-Definitions,abstract type definition>>:
it tells the analyzer that a state machine exists with a specified
name, but it says nothing about the state machine behavior.
An external tool must provide the state machine implementation.

. An *internal* state machine definition is similar to an
<<Defining-Types_Array-Type-Definitions,array type definition>>
or
<<Defining-Types_Struct-Type-Definitions,struct type definition>>:
it provides a complete specification in FPP of the state machine behavior.
The FPP back end uses this specification to generate code;
no external tool is required.

The following subsections describe both kinds of state machine
definitions.

State machine definitions may appear at the top level or inside a
<<Defining-Modules,module definition>>.
A state machine definition is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>.
Once you define a state machine, you can
<<Defining-Components_State-Machine-Instances,
instantiate it as part of a component>>.


=== External State Machines

To define an external state machine, you write the keywords
`state` `machine` followed by an identifier, which is the
name of the state machine:

[source,fpp]
----
state machine M
----

This code defines an external state machine with name `M`.

When you define an external state machine `M`, you must provide
an implementation for `M`, as discussed in the section
on <<Writing-C-Plus-Plus-Implementations_Implementing-External-State-Machines,
implementing external state machines>>.
The external implementation must have a header file `M.hpp`
located in the same directory as the FPP file where
the state machine `M` is defined.

=== Basic Internal State Machines

The most basic useful internal state machine `M` consists of the following:

* Several *state definitions*.
These define the states of `M`.

* An *initial transition specifier*.
This specifies the state that an instance of `M` is in when it starts up.

* One or more *signals* that cause `M` to change state.
The external environment (typically an F Prime component)
sends signals to instance of `M`.

* One or more *state transition specifiers*.
These tell each instance of `M` what to do when it receives a signal.

Here is an example:

[source,fpp]
----
@ A state machine representing a device with on-off behavior
state machine Device {

  @ A signal for turning the device on
  signal deviceOn

  @ A signal for turning the device off
  signal deviceOff

  @ The initial state is OFF
  initial enter OFF

  @ The ON state
  state ON {

    @ In the ON state, a deviceOff signal causes a transition to the OFF state
    on deviceOff enter OFF

  }

  @ The OFF state
  state OFF {

    @ In the OFF state, a deviceOff signal causes a transition to the ON state
    on deviceOn enter ON

  }

}
----

This example defines a state machine `Device` that represents
a device with on-off behavior.
There are two states, `ON` and `OFF`.
The initial transition specifier `initial enter OFF`
says that the state machine is in state `OFF` when it starts up.
There are two signals: `deviceOn` for turning the device
on and `deviceOff` for turning the device off.
There are two state transition specifiers:

* A specifier that says to enter state `OFF` 
on receiving the `deviceOff` signal in state `ON`.

* A specifier that says to enter state `ON`
on receiving the `deviceOn` signal in state `OFF`.

State transition specifiers cause transitions from the states
in which they appear.
In this example, if the state machine receives signal
`deviceOn` in state `ON`
or signal `deviceOff` in state `OFF`, then it takes no action.

*Rules for writing state machine definitions:*
State machine definitions must conform to the following rules:

. A state machine definition and each of its members is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>.
For example, you can annotate the `Device` state machine as shown above.
The members of a state machine definition form an
<<Defining-Constants_Multiple-Definitions-and-Element-Sequences,
element sequence>> with a semicolon as the optional
terminating punctuation.
The same rules apply to the members of a state definition.

. Each state machine definition must have exactly one
initial transition specifier that names a state of
the state machine.
For example, if we deleted the initial transition specifier
from the example above and passed the result through
`fpp-check`, and error would occur.

. Every state definition must be reachable from the initial
transition specifier or from a state transition specifier.
For example, if we deleted the state transition specifier
in the state `ON` from the example above and passed
the result through `fpp-check`, an error would occur.
In this case, there would be no way to reach the `ON` state.

*Simple state definitions:*
If a state definition has no transitions, then you can omit
the braces.
For example, here is a revised version of the `Device` state
machine that has an off-on transition but no on-off transition:

[source,fpp]
----
@ A state machine representing a device with on-only behavior
state machine Device {

  @ A signal for turning the device on
  signal deviceOn

  @ The initial state is OFF
  initial enter OFF

  @ The ON state
  state ON

  @ The OFF state
  state OFF {

    @ In the OFF state, a deviceOff signal causes a transition to the ON state
    on deviceOn enter ON

  }

}
----

=== Actions

TODO

* On initial transitions
* On state transitions

=== Entry and Exit Specifiers

TODO

=== Typed Signals and Actions

TODO

=== Guarded Transitions

TODO

=== Transitions to Self

TODO

=== Internal Transitions

TODO

=== Junctions

TODO

* Basic
* With actions

* Rules
** Reachability
** No junction cycles
** Types must work out at junctions

=== State Hierarchy

TODO

==== States within States

TODO

* Rules
** Exactly one initial transition specifier
** Initial transition specifier must lead to a peer state

==== Inherited Transitions

TODO

==== Transitions to Self

TODO

==== Junctions within States

TODO

* Rules
** Initial transition specifier must lead to a peer state or junction
