== Defining State Machines

A *hierarchical state machine* (state machine for short)
specifies the following:

* A set of *states* that a system can be in.
The states can be arranged in a hierarchy (i.e.,
states may have substates).

* A set of *transitions* from one state to another that
occur under specified conditions.

State machines are important in embedded programming.
For example, F Prime components often have a concept of state
that changes as the system runs, and it is useful to model
these state changes as a state machine.

In FPP there are two ways to define a state machine:

. An *external* state machine definition is similar to
an <<Defining-Types_Abstract-Type-Definitions,abstract type definition>>:
it tells the analyzer that a state machine exists with a specified
name, but it says nothing about the state machine behavior.
An external tool must provide the state machine implementation.

. An *internal* state machine definition is similar to an
<<Defining-Types_Array-Type-Definitions,array type definition>>
or
<<Defining-Types_Struct-Type-Definitions,struct type definition>>:
it provides a complete specification in FPP of the state machine behavior.
The FPP back end uses this specification to generate code;
no external tool is required.

The following subsections describe both kinds of state machine
definitions.

State machine definitions may appear at the top level or inside a
<<Defining-Modules,module definition>>.
A state machine definition is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>.
Once you define a state machine, you can
<<Defining-Components_State-Machine-Instances,
instantiate it as part of a component>>.
The component can then send the signals that cause the state
transitions.

=== External State Machines

To define an external state machine, you write the keywords
`state` `machine` followed by an identifier, which is the
name of the state machine:

[source,fpp]
----
state machine M
----

This code defines an external state machine with name `M`.

When you define an external state machine `M`, you must provide
an implementation for `M`, as discussed in the section
on <<Writing-C-Plus-Plus-Implementations_Implementing-External-State-Machines,
implementing external state machines>>.
The external implementation must have a header file `M.hpp`
located in the same directory as the FPP file where
the state machine `M` is defined.

=== Basic Internal State Machines

The simplest internal state machine `M` that has any useful
behavior consists of the following:

* Several *state definitions*.
These define the states of `M`.

* An *initial transition specifier*.
This specifies the state that an instance of `M` is in when it starts up.

* One or more *signals* that cause `M` to change state.
The external environment (typically an F Prime component)
sends signals to instance of `M`.

* One or more *state transition specifiers*.
These tell each instance of `M` what to do when it receives a signal.

Here is an example:

[source,fpp]
----
@ A state machine representing a device with on-off behavior
state machine Device {

  @ A signal for turning the device on
  signal deviceOn

  @ A signal for turning the device off
  signal deviceOff

  @ The initial state is OFF
  initial enter OFF

  @ The ON state
  state ON {

    @ In the ON state, a deviceOff signal causes a transition to the OFF state
    on deviceOff enter OFF

  }

  @ The OFF state
  state OFF {

    @ In the OFF state, a deviceOff signal causes a transition to the ON state
    on deviceOn enter ON

  }

}
----

This example defines a state machine `Device` that represents
a device with on-off behavior.
There are two states, `ON` and `OFF`.
The initial transition specifier `initial enter OFF`
says that the state machine is in state `OFF` when it starts up.
There are two signals: `deviceOn` for turning the device
on and `deviceOff` for turning the device off.
There are two state transition specifiers:

* A specifier that says to enter state `OFF` 
on receiving the `deviceOff` signal in state `ON`.

* A specifier that says to enter state `ON`
on receiving the `deviceOn` signal in state `OFF`.

In general, state transition specifiers cause transitions from the states
in which they appear.
In this example, if the state machine receives signal
`deviceOn` in state `ON`
or signal `deviceOff` in state `OFF`, then it takes no action.

*Rules for writing state machine definitions:*
State machine definitions must conform to the following rules:

. A state machine definition and each of its members is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>.
For example, you can annotate the `Device` state machine as shown above.
The members of a state machine definition form an
<<Defining-Constants_Multiple-Definitions-and-Element-Sequences,
element sequence>> with a semicolon as the optional
terminating punctuation.
The same rules apply to the members of a state definition.

. Each state machine definition must have exactly one
initial transition specifier that names a state of
the state machine.
For example, if we deleted the initial transition specifier
from the example above and passed the result through
`fpp-check`, and error would occur.

. Every state definition must be reachable from the initial
transition specifier or from a state transition specifier.
For example, if we deleted the state transition specifier
in the state `ON` from the example above and passed
the result through `fpp-check`, an error would occur.
In this case, there would be no way to reach the `ON` state.

. Every state name must be unique, and every signal name
must be unique.

*Simple state definitions:*
If a state definition has no transitions, then you can omit
the braces.
For example, here is a revised version of the `Device` state
machine that has an off-on transition but no on-off transition:

[source,fpp]
----
@ A state machine representing a device with on-only behavior
state machine Device {

  @ A signal for turning the device on
  signal deviceOn

  @ The initial state is OFF
  initial enter OFF

  @ The ON state
  state ON

  @ The OFF state
  state OFF {

    @ In the OFF state, a deviceOff signal causes a transition to the ON state
    on deviceOn enter ON

  }

}
----

Notice that state `ON` has a simple definition with no curly braces.

=== Actions

An *action* is a function that a state machine calls at a
specified point in its behavior.
In the FPP model, actions are abstract:
In the {cpp} back end they become pure virtual functions that
you implement.
Running the function for an action _A_ is called 
*doing* _A_.

To specify an action, you write the keyword `action` followed
by the name of the action.
As with <<Defining-State-Machines_Basic-Internal-State-Machines,signals>>,
every action name must be unique.
To do an action, you write the keyword `do`
followed by a list of action names enclosed in curly braces.
You can do this in an initial transition specifier or in a
state transition specifier.

As an example, here is the `Device` state machine from the
previous section, with actions added:

[source,fpp]
----
@ A state machine representing a device with on-off behavior,
@ with actions on transitions
state machine Device {

  @ Initial action 1
  action initialAction1

  @ Initial action 2
  action initialAction2

  @ An action on the transition from OFF to ON
  action offOnAction

  @ An action on the transition from ON to OFF
  action onOffAction

  @ A signal for turning the device on
  signal deviceOn

  @ A signal for turning the device off
  signal deviceOff

  @ The initial state is OFF
  @ Before entering the initial state, do initialAction1 and then initialAction2
  initial do { initialAction1, initialAction2 } enter OFF

  @ The ON state
  state ON {

    @ In the ON state, a deviceOff signal causes a transition to the OFF state
    @ Before entering the OFF state, do onOffAction
    on deviceOff do { onOffAction } enter OFF

  }

  @ The OFF state
  state OFF {

    @ In the OFF state, a deviceOff signal causes a transition to the ON state
    @ Before entering the ON state, do offOnAction
    on deviceOn do { offOnAction } enter ON

  }

}
----

In this example there are four actions:
`initialAction1`, `initialAction2`, `offOnAction`, and `onOffAction`.
The behavior of each of these actions is specified in the {cpp}
implementation; for example, each could emit an 
<<Defining-Components_Events,F Prime event>>.
The state machine has the following behavior:

* On startup, do `initialAction1`, do `initialAction2`, and
enter the `OFF` state.

* In state `OFF`, on receiving the `deviceOn` signal, do
`offOnAction` and enter the `ON` state.

* In state `ON`, on receiving the `deviceOff` signal, do
`onOffAction` and enter the `OFF` state.

When multiple actions appear in an action list, as in the initial
transition specifier shown above, the actions occur in the order
listed.
Each action list is an
<<Defining-Constants_Multiple-Definitions-and-Element-Sequences,
element sequence>> with a comma as the optional
terminating punctuation.

=== State Entry and Exit Specifiers

In addition to doing actions on transitions, a state machine
can do actions on entry to or exit from a state.
To specify these actions, you write *state entry specifiers*
and *state exit specifiers*.
For example, here is the `Device` state machine from
the previous section, with state entry and exit specifiers
added to the `ON` and `OFF` states:

[source,fpp]
----
@ A state machine representing a device with on-off behavior,
@ with actions on transitions and on state entry and exit
state machine Device {

  @ Initial action 1
  action initialAction1

  @ Initial action 2
  action initialAction2

  @ An action on the transition from OFF to ON
  action offOnAction

  @ An action on the transition from ON to OFF
  action onOffAction

  @ An action on entering the ON state
  action enterOn

  @ An action on exiting the ON state
  action exitOn

  @ An action on entering the OFF state
  action enterOff

  @ An action on exiting the OFF state
  action exitOff

  @ A signal for turning the device on
  signal deviceOn

  @ A signal for turning the device off
  signal deviceOff

  @ The initial state is OFF
  @ Before entering the initial state, do initialAction1 and then initialAction2
  initial do { initialAction1, initialAction2 } enter OFF

  @ The ON state
  state ON {

    @ On entering the ON state, do enterOn
    entry do { enterOn }

    @ In the ON state, a deviceOff signal causes a transition to the OFF state
    @ Before entering the OFF state, do offAction
    on deviceOff do { onOffAction } enter OFF

    @ On exiting the ON state, do exitOn
    exit do { exitOn }

  }

  @ The OFF state
  state OFF {

    @ On entering the OFF state, do enterOff
    entry do { enterOff }

    @ In the OFF state, a deviceOff signal causes a transition to the ON state
    @ Before entering the ON state, do onAction
    on deviceOn do { offOnAction } enter ON

    @ On exiting the OFF state, do exitOff
    exit do { exitOff }

  }

}
----

As with actions on transitions, each entry or exit specifier names
a list of actions, and they are done in the order named.
The entry actions are done just before entering the state,
and the exit actions are done just before exiting the state.
For example, if the state machine is in state `OFF` and it
receives a `deviceOn` signal, then it runs the following behavior,
in the following order:

* Exit state `OFF`. On exit, do `exitOff`.

* Transition from `OFF` to `ON`. On the transition, do `offOnAction`.

* Enter state `ON`. On entry, do `enterOn`.

Each state may have at most one entry specifier and at most one
exit specifier.

=== Typed Signals and Actions

Optionally, signals and actions may carry data values.
To specify that a signal or action carries a data value,
you write a colon and a data type at the end of the
signal or action specifier.
For example, here is a `Device` state machine in which
the `deviceOn` signal and the `offOnAction` each carries
a `U32` counter value:

[source,fpp]
----
@ A state machine representing a device with on-off behavior,
@ with actions on transitions
state machine Device {

  @ An action on the transition from OFF to ON
  @ The value counts the number of times this action has occurred
  action offOnAction: U32

  @ A signal for turning the device on
  @ The value counts the number of times this signal has been received
  signal deviceOn: U32

  @ A signal for turning the device off
  signal deviceOff

  @ The initial state is OFF
  initial enter OFF

  @ The ON state
  state ON {

    @ In the ON state, a deviceOff signal causes a transition to the OFF state
    on deviceOff enter OFF

  }

  @ The OFF state
  state OFF {

    @ In the OFF state, a deviceOff signal causes a transition to the ON state
    @ Before entering the ON state, do offOnAction, passing the data from
    @ the signal into the action
    on deviceOn do { offOnAction } enter ON

  }

}
----

When you send the `deviceOn` signal to an instance of
this state machine, you are required to provide a `U32` value.
When the state machine is in the `OFF` state and it receives
this signal, it does action `offOnAction` as shown.
The function that defines the behavior of `offOnAction` has
a single argument of type `U32`.
The value provided when the signal is sent is passed as the
argument to this function.

Here are the rules for writing typed signals and actions:

* When you do an action that has a type, a value
compatible with that type must be available.
For example, we can't do the `offOnAction` in the `deviceOff` transition shown 
above, because no `U32`
value is available there.
Similarly, no action done in a
<<Defining-State-Machines_State-Entry-and-Exit-Specifiers,
state entry or exit specifier>> may carry a value,
because no values are available on entry to or exit
from a state.

* The type that appears in a signal or an action can
be any FPP type.
In the example above we used a simple `U32` type,
but we could have used, for example, be a struct or array type.

* When doing an action with a value, you don't have to
make the types exactly match.
For example, you are permitted to pass a `U16` value
to an action that requires a `U32` value.
However, the type of the value must be convertible to the type
specified in the action.
The type conversion rules are spelled out in full in
_The FPP Language Specification_.
In general, the analyzer will allow a conversion if it
can be safely done for all values of the original type.

* If an action _A_ does not carry any value, then you
can do _A_ in a context where a value is available.
For example, in the code shown above, the `deviceOn`
transition could do some other action that carries no value.
In this case the value is ignored when doing the action.

=== Guarded Transitions

TODO

=== Transitions to Self

TODO

=== Internal Transitions

TODO

=== Choices

TODO

* Basic
* With actions

* Rules
** Reachability
** No choice cycles
** Types must work out at choices

=== State Hierarchy

TODO

==== States within States

TODO

* Rules
** Exactly one initial transition specifier
** Initial transition specifier must lead to a peer state

==== Inherited Transitions

TODO

==== Transitions to Self

TODO

==== Choices within States

TODO

* Rules
** Initial transition specifier must lead to a peer state or choice
